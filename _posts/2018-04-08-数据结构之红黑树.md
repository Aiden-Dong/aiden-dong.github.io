---
pin: true
title:      数据结构 | 红黑树

date:       2018-04-08
author:     Aiden
image: 
    path : source/internal/post-bg-swift.jpg
categories : ['Base']
tags : ['算法']
---

### 介绍:

红黑树是一个平衡的二叉树，但不是一个完美的平衡二叉树。虽然我们希望一个所有查找都能在~lgN次比较内结束，但是这样在动态插入中保持树的完美平衡代价太高，所以，我们稍微放松逛一下限制，希望找到一个能在对数时间内完成查找的数据结构。这个时候，红黑树站了出来。

红黑树是在普通二叉树上，对每个节点添加一个颜色属性形成的，同时整个红黑二叉树需要同时满足一下五条性质:

1. **每个节点或者是黑色，或者是红色。**
2. **根节点是黑色。**
3. **每个叶子节点是黑色.[注意：这里叶子节点，是指为空的叶子节点！]**
4. **如果一个节点是红色的，则它的子节点必须是黑色的。**
5. **从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

![image.png]({{ site.url }}/source/nodebook/ds_10_1.png)

### 平衡性修正:

> 我们处理红黑树的核心思想：**将红色的节点移到根节点；然后，将根节点设为黑色**。

红-黑树主要通过三种方式对平衡进行修正，**改变节点颜色**、**左旋**和**右旋**。这看起来有点抽象，我们分别来介绍它们。


#### 1. 变色

改变节点颜色比较容易理解，因为它违背了规则3。假设现在有个节点E，然后插入节点A和节点S，节点A在左子节点，S在右子节点，目前是平衡的。如果此时再插一个节点，那么就出现了不平衡了，因为红色节点的子节点必须为黑色，但是新插的节点是红色的。所以这时候就必须改变节点颜色了。所以我们将根的两个子节点从红色变为黑色（至于为什么都要变，下面插入的时候会详细介绍），将父节点会从黑色变成红色。可以用如下示意图表示一下：

#### 2. 左旋


通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。示意图如下：

![image.png]({{ site.url }}/source/nodebook/ds_10_2.png)

上面对左旋的概念已经有了感性的认识了，这里就不再赘述了，我们从下面的代码中结合上面的示意图，探讨一下左旋的具体实现：

```
/*************对红黑树节点x进行左旋操作 ******************/  
/*
 * 左旋示意图：对节点x进行左旋
 *     p                       p
 *    /                       /
 *   x                       y
 *  / \                     / \
 * lx  y      ----->       x  ry
 *    / \                 / \
 *   ly ry               lx ly
 * 左旋做了三件事：
 * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)
 * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
 * 3. 将y的左子节点设为x，将x的父节点设为y
 */  
private void leftRotate(RBNode<T> x) {  
    //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)  
    RBNode<T> y = x.right;  
    x.right = y.left;  

    if(y.left != null)   
        y.left.parent = x;  

    //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)  
    y.parent = x.parent;  

    if(x.parent == null) {  
        this.root = y; //如果x的父节点为空，则将y设为父节点  
    } else {  
        if(x == x.parent.left) //如果x是左子节点  
            x.parent.left = y; //则也将y设为左子节点  
        else  
            x.parent.right = y;//否则将y设为右子节点  
    }  

    //3. 将y的左子节点设为x，将x的父节点设为y  
    y.left = x;  
    x.parent = y;         
}     
```

#### 3. 右旋

右旋可左旋刚好相反，这里不再赘述，直接看示意图：

![image.png]({{ site.url }}/source/nodebook/ds_10_3.png)


上面对右旋的概念已经有了感性的认识了，这里也不再赘述了，我们从下面的代码中结合上面的示意图，探讨一下右旋的具体实现：

```
/*************对红黑树节点y进行右旋操作 ******************/  
/*
 * 左旋示意图：对节点y进行右旋
 *        p                   p
 *       /                   /
 *      y                   x
 *     / \                 / \
 *    x  ry   ----->      lx  y
 *   / \                     / \
 * lx  rx                   rx ry
 * 右旋做了三件事：
 * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)
 * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)
 * 3. 将x的右子节点设为y，将y的父节点设为x
 */  
private void rightRotate(RBNode<T> y) {  
    //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)  
    RBNode<T> x = y.left;  
    y.left = x.right;  

    if(x.right != null)   
        x.right.parent = y;  

    //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)  
    x.parent = y.parent;  

    if(y.parent == null) {  
        this.root = x; //如果x的父节点为空，则将y设为父节点  
    } else {  
        if(y == y.parent.right) //如果x是左子节点  
            y.parent.right = x; //则也将y设为左子节点  
        else  
            y.parent.left = x;//否则将y设为右子节点  
    }  

    //3. 将y的左子节点设为x，将x的父节点设为y  
    x.right = y;  
    y.parent = x;         
}    
```


### 插入:

#### 1. 插入步骤:

> **将一个节点插入到红黑树中，需要执行哪些步骤呢？**

首先，将红黑树当作一颗二叉查找树，将节点插入;然后,**将该节点着色为红色**;
最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：

##### 第一步: 将红黑树当作一颗二叉查找树，将节点插入:

红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。
也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。
这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！

##### 第二步：将插入的节点着色为"红色":

为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：

将插入的节点着色为红色，不会违背"**特性(5)**[从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节])"！
少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o...哈哈


##### 第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。

对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。
对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。如果原二叉树为空树，则插入后节点直接变色即可。
对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。
对于"特性(4)"，是有可能违背的！
那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。

#### 2.调整情况

> **根据被插入节点的父节点的情况，可以将"当节点z被着色为红色节点，并插入二叉树"划分为三种情况来处理。**

##### 情况说明 1 : 被插入的节点是根节点(空树)。

处理方法：直接把此节点涂为黑色。

##### 情况说明 2 : 被插入的节点的父节点是黑色。

处理方法：什么也不需要做。节点被插入后，仍然是红黑树。

##### 情况说明 3：被插入的节点的父节点是红色。

处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的;
进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。
理解这点之后，我们依据"叔叔节点的情况"，将这种情况进一步划分为3种情况(Case)。


#### 3. 调整方式：

##### (Case 1)叔叔是红色

![image.png]({{ site.url }}/source/nodebook/ds_10_4.png)

1. 现象说明:

当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。

2. 处理策略:

01 将“父节点”设为黑色。
02 将“叔叔节点”设为黑色。
03 将“祖父节点”设为“红色”。
04 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。

3. 处理原因:

"当前节点"和"父节点"都是红色，违背"特性(4)"。 所以，将"父节点"设置"黑色"以解决这个问题。

**但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。**
解决这个问题的办法是：将"祖父节点"由"黑色"变成红色，同时，将"叔叔节点"与"父节点"由"红色"变成"黑色"。
> 关于这里，说明几点：
第一，为什么“祖父节点”之前是黑色？
这个应该很容易想明白，因为在变换操作之前，该树是红黑树，"父节点"是红色，那么"祖父节点"一定是黑色。

第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。

这个道理也很简单。包含"父节点"的分支的黑色节点的总数增加了1. 同时也意味着包含"祖父节点"的分支的黑色节点的总数增加了1，既然这样，我们通过将"祖父节"点由黑色变成红色以解决包含"祖父节点"的分支的黑色节点的总数增加了1的问题;

但是，这样处理之后又会引起另一个问题:包含"叔叔"节点的分支的黑色节点的总数减少了1，现在我们已知"叔叔节点"是"红色"，将"叔叔节点"设为"黑色"就能解决这个问题。
所以，将"祖父节点"由"黑色"变成红色，同时，将"叔叔节点"由"红色"变成"黑色";就解决了该问题。

按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为"黑色"，那就完全解决这个问题了;
若祖父节点不是根节点，那我们需要将"祖父节点"设为"新的当前节点"，接着对"新的当前节点"进行分析。

##### (Case 2)叔叔是黑色，且当前节点是右孩子:

![image.png]({{ site.url }}/source/nodebook/ds_10_5.png)


1. 现象说明:

当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子

2. 处理策略:

(01) 将"父节点"作为"新的当前节点"。
(02) 以"新的当前节点"为支点进行左旋。

3. 处理原因:

为了便于理解，我们先说明第(02)步，再说明第(01)步:

为了便于说明，我们设置"父节点"的代号为F(Father)，"当前节点"的代号为S(Son)。

为什么要"以F为支点进行左旋"呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：**将红色的节点移到根节点；然后，将根节点设为黑色。**
既然是"将红色的节点移到根节点"，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过"左旋"来将S上移！

按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为"黑色"，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01).
即"将F设为**新的当前节点**"。

那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？

这是因为"左旋"之后，F变成了S的"子节点"，即S变成了F的父节点; 而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理; 也就是说，必须先解决"孩子"的问题，再解决"父亲"的问题;
所以，我们执行步骤(01)：将"父节点"作为"新的当前节点"。

##### (Case 3)叔叔是黑色，且当前节点是左孩子:

![image.png]({{ site.url }}/source/nodebook/ds_10_6.png)

1. 现象说明:

当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子

2. 处理策略:

(01) 将"父节点"设为"黑色"。
(02) 将"祖父节点"设为"红色"。
(03) 以"祖父节点"为支点进行右旋。

3. 处理原因:


为了便于说明，我们设置"当前节点"为S(Original Son)，"兄弟节点"为B(Brother)，"叔叔节点"为U(Uncle)，"父节点"为F(Father)，祖父节点为G(Grand-Father)。

S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。


##### 插入代码:

```
private void insertFixUp(RBNode<T> node) {  
    RBNode<T> parent, gparent; //定义父节点和祖父节点  

    //需要修整的条件：父节点存在，且父节点的颜色是红色  
    while(((parent = parentOf(node)) != null) && isRed(parent)) {  
        gparent = parentOf(parent);//获得祖父节点  

        //若父节点是祖父节点的左子节点，下面else与其相反  
        if(parent == gparent.left) {                  
            RBNode<T> uncle = gparent.right; //获得叔叔节点  

            //case1: 叔叔节点也是红色  
            if(uncle != null && isRed(uncle)) {  
                setBlack(parent); //把父节点和叔叔节点涂黑  
                setBlack(uncle);  
                setRed(gparent); //把祖父节点涂红  
                node = gparent; //将位置放到祖父节点处  
                continue; //继续while，重新判断  
            }  

            //case2: 叔叔节点是黑色，且当前节点是右子节点  
            if(node == parent.right) {  
                leftRotate(parent); //从父节点处左旋  
                RBNode<T> tmp = parent; //然后将父节点和自己调换一下，为下面右旋做准备  
                parent = node;  
                node = tmp;  
            }  

            //case3: 叔叔节点是黑色，且当前节点是左子节点  
            setBlack(parent);  
            setRed(gparent);  
            rightRotate(gparent);  
        } else { //若父节点是祖父节点的右子节点,与上面的完全相反，本质一样的  
            RBNode<T> uncle = gparent.left;  

            //case1: 叔叔节点也是红色  
            if(uncle != null & isRed(uncle)) {  
                setBlack(parent);  
                setBlack(uncle);  
                setRed(gparent);  
                node = gparent;  
                continue;  
            }  

            //case2: 叔叔节点是黑色的，且当前节点是左子节点  
            if(node == parent.left) {  
                rightRotate(parent);  
                RBNode<T> tmp = parent;  
                parent = node;  
                node = tmp;  
            }  

            //case3: 叔叔节点是黑色的，且当前节点是右子节点  
            setBlack(parent);  
            setRed(gparent);  
            leftRotate(gparent);  
        }  
    }  

    //将根节点设置为黑色  
    setBlack(this.root);  
}
```